redo日志、undo日志未完成

架构、索引、锁、语法、理论范式

架构：RDBMS包含模块：存储管理+缓存机制+SQL解析+日志管理+权限划分+容灾机制+索引管理+锁管理

# 一、索引模块

1. 为什么使用索引：快速查询数据

2. 什么样的信息能成为索引：主键、唯一键、普通键

3. 索引的数据结构：二叉查找树、B树、B+树、Hash

   > 二叉查找树(左子树节点<根节点<右子树节点)：
   >
   > ​	时间复杂度最差O(n)；每个树两个子节点，需要I/O为O(logn)
   >
   > B树(根节点至少两个孩子+内节点至少ceil(m/2)个孩子+每个节点最多m个孩子+所有叶子节点同一层+每个key>其左边指向的节点，且<其右边指向的节点)
   >
   > B+树(非叶子节点key的个数与指针个数相同+P[i]指针下的子树关键字值[key[i], key[i+1])+非叶子节点只用于索引，数据在叶子节点中+所有叶子节点都有指针，指向下一叶子节点)
   >
   > ​	B+树节点只有关键字值，没有节点信息，比B树小；查询效率稳定；有利于数据库扫描
   >
   > Hash
   >
   > ​	只能等值查询；无法排序；不能利用部分索引键做查询；不能避免表扫描；冲突多时效率低

4. 密集索引和稀疏索引区别

   > 密集索引：每个搜索码对应一个索引值
   >
   > 稀疏索引：只为索引码某些值建立索引项<img src="E:\java找工作\总结\java总结\图片\Mysql\索引.png" alt="索引" style="zoom: 50%;" />
   >
   > MyISAM主键、唯一键、普通键均为稀疏索引
   >
   > InnoDB有且只有一个密集索引：(主键、第一个唯一非空索引、内部生成隐藏主键)，其他为稀疏索引

5. 如何定位并优化慢查询Sql：(具体场景具体分析)

   > (1)根据慢日志定位慢查询Sql：slow_query_log(on)、long_query_time(1)、slow_query_log_file
   >
   > (2)使用explain等工具分析Sql：type(index/all全表扫描)、extra(Using filesort在内存或磁盘排序、Using 	temporary在查询结果时使用临时表)
   >
   > (3)修改sql或尽量让sql走索引：

6. 联合索引的最左匹配原则的成因

   > 最左前缀匹配原则，mysql一直向右匹配直到遇到范围查询，其中左边可以使用索引的列顺序可互换

7. 索引是建立越多越好吗

   > 数据量小的表不需要建立索引，建立索引会增加开销
   >
   > 数据表变更时需要维护索引，索引越多，则需要更多维护成本
   >
   > 更多索引占用更多空间

# 二、锁

1. MyISAM与InnoDB关于锁方面的区别

   > (1)MyISAM默认使用**表级锁**，不支持行级锁		(与索引无关)
   >
   > ​		select时，会自动加上表级读锁(共享锁)，增删改时，会加上表级写锁(排他锁)
   >
   > ​		select时，末尾加上for updata，为加上排他锁
   >
   > ​		手动加锁解锁：lock tables 表名 read/write;  unlock tables;
   >
   >    InnoDB默认使用**行级锁**，也支持表级锁，意向锁(IS)，排他写锁(IX)
   >
   > ​		手动加锁解锁：select时，末尾加上lock in share mode(加读锁)
   >
   > ​		当不走索引时(全表查询)，用的是表级锁；用到索引时，使用行级锁、gap锁(普通非唯一索引使用)
   >
   > **适合场景：**
   >
   > ​	MyISAM：频繁执行全表count语句；对数据增删改少查询多；没有事务
   >
   > ​	InnoDB：数据增删改查都相当频繁；要求支持事务
   >
   > **锁的分类：**
   >
   > ​	按照锁的粒度划分，可分为表级锁、页级锁、行级锁
   >
   > ​	按锁级别划分，可分为共享锁、排他锁
   >
   > ​	按加锁方式，可分为自动锁、显式锁
   >
   > ​	按照操作划分，可分为DML锁、DDL锁
   >
   > ​	按使用方式划分，可分为乐观锁、悲观锁

2. 数据库事务四大特性：原子性、一致性、隔离性、持久性

3. 事务隔离级别以及各级别下的并发访问问题

   > **引发问题**：(1)更新丢失
   >
   > ​		(2)脏读(一个事务读到另一个事务未提交数据)READ-COMMITTED已提交读
   >
   > ​		(3)不可重复读(一个事务多次读取结果不一致)REPEATABLE-READ
   >
   > ​		(4)幻读(一个事务)SERIALIZABLE避免
   >
   > **隔离级别**：select @@tx_isolation;

4. InnoDB可重复读隔离级别下如何避免幻读

   > 表象：快照读(非阻塞读)-----伪MVCC
   >
   > ​		当前读：加了锁的增删改查语句(保证读到的是最新版本，且其他事务不能修改)
   >
   > ​		快照读：不加锁的非阻塞读，select(非SERIALIZABLE级别)
   >
   > 
   >
   > 内在：next-key锁(行锁+gap锁)
   >
   > ​		行锁：对单个记录行上的锁
   >
   > ​		gap锁：(gap索引树中插入新纪录的空隙)锁定一个范围，但不包括记录本身，为防止同一事物两次当前读出现幻读(RR及SERIALIZABLE支持)；
   >
   > ​			gap锁用在**非唯一索引**或**不走索引**的**当前读**中
   >
   > ​			非唯一索引：gap锁：(-无穷, 10]、(10, 13]、(13, 20]、(20, +无穷](id列为10、13、20)，当session1修改13时，(10, 13]、(13, 20]两区间被上锁，session2无法修改此区间对应的数据，当session2修改10时，会根据10对应行主键的值进行上锁，其右边的上锁，左边的不上锁 
   >
   > ​			不走索引：表中所有gap均会被锁住(-无穷, +无穷)

   4.1 RR条件下，删改查，当前读若用到主键或唯一键，会用到gap锁吗？

   > 若where条件全部命中(WHERE子句中条件对应行都成立)，不会用gap锁，只会加记录锁
   >
   > 若where条件部分命中或全不命中，则会加gap锁

5. RC(READ-COMMITTED)、RR(REPEATABLE-READ)级别下的InnoDB非阻塞读如何实现

   > RC级别下当前读和快照读结果一样
   >
   > RR级别下当前读和快照度结果不一样，当前读是数据最新版本，(如果在首次更新数据之前进行过快照读，则之后快照读是数据旧版本；如果是更新后进行快照读，则快照读也是更新后的数据)
   >
   > **名次解释：**
   >
   > ​		①数据行里的DB_TRX_ID(最后一次修改本行的事务ID)、DB_ROLL_PTR(回滚指针)、DB_ROW_ID(隐藏主键)字段
   >
   > ​		②undo日志：改变某记录时会有undo记录，存储老版数据<img src="E:\java找工作\总结\java总结\图片\Mysql\undo记录.png" alt="undo记录" style="zoom:50%;" />
   >
   > ​		③read view：可见性判断，判断当前查询看到的是哪个版本数据(通过要修改数据的DB_TRX_ID与事务ID作对比)
   >
   > **实现**：
   >
   > ​	REPEATABLE-READ ：session第一条快照读，会创建一个快照read_view，将当前系统中活跃的其他事务记录，之后调用快照读的时候，还是使用此read_view
   >
   > ​	READ-COMMITTED：每次调用快照读都会创建一个新的快照
   >
   > 

# 1. 重新认识MySQL

### 1.1 MySQL运行原理

MySQL也是C/S架构，有服务器程序和客户端程序，客户端程序发送请求到服务器程序，服务器程序完成处理后返回结果。

**MySQL运行流程：**

1. 启动MySQL服务器程序(mysqld)

2. 启动客户端程序并连接服务器程序(mysql -h -u -p)

   连接时可以选择TCP/IP、命名管道和共享内存、Unix域套接字文件

3. 服务器处理客户端请求

   分为连接管理、解析与优化、存储引擎

#### 1.1.1 服务器处理客户端请求

**1. 连接管理：**

1. 客户端进程与服务器进行建立连接(服务器用**线程池**创建线程与客户端交互)

2. 连接建立后，服务器线程会一等待客户端发送请求

**2. 解析与优化：**

​	(1) 查询缓存：将一个客户端的查询结果进行缓存，方便**所有**客户端查询

> 1. 缓存可在不同客户端之间共享
> 2. 如果查询请求包含系统函数、用户自定义函数和变量、一些系统表，则不会被缓存
> 3. 当该表的结构或数据被修改时，缓存失效。

​	(2) 语法解析：服务器程序对客户端的请求文本做分析，判断请求是否正确、将查询的关键字段提取

​	(3) 查询优化：对查询语句做优化

**3. 存储引擎：**

之前的操作只是针对接受请求，存储引擎是真正和数据库打交道的部分，包括数据存储、提取等操作。常用的有InnoDB(外键+事务)、MySAIM(非事务)

> 可为不同表设置不同的存储引擎



# 2. MySQL启动选项、系统变量

### 2.1 启动选项

程序启动时指定的设置项称**启动选项**，多个单词用下划线连接，如果启动选项在命令行和配置文件都出现，则以命令行为准。

#### 2.1.1 命令行启动

1. **长形式**

   通用格式：将各个启动选项写到⼀⾏中， 各个启动选项之间使⽤空⽩字符隔开， 在每⼀个启动选项名称前边添加--

   > --启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[=值n]

   选项名、 =、 选项值之间不可以有空⽩字符

2. **短形式**

   通用格式：将各个启动选项写到⼀⾏中，各个启动选项之间使⽤空⽩字符隔开， 在每⼀个启动选项名称前边添加--

   > 使⽤短形式指定启动选项时， 选项名和选项值之间可以没有间隙， 或者⽤空⽩字符隔开（-p选项有些特殊， -p和密码值之间不能有空⽩字符）

   选项名是区分⼤⼩写的，-p(表示密码)；-P(表示端口)

#### 2.1.2 配置文件启动

1. **配置文件路径**

2. **配置文件内容**

   > [server] 
   >
   > (具体的启动选项...)    #option1    不需要值的选项
   > [mysqld] 
   >
   > (具体的启动选项...)    #option2    需要值的选项
   >
   > ……

   配置文件中只能使用长形式，不允许加--前缀，每行只能一个选项，=左右可以有空格，#用来行注释

   [server]下启动选项作用于所有服务器程序        [client]下启动选项作用于所有客户端程序

   选项组间有读取关系

3. **优先级**

   * MySQL按照顺序读取各配置文件，多个配置文件中设置了相同的启动项，则以最后一个配置文件中的为准
   * 一个配置文件中不同的组的配置发生冲突(如server、mysqld)，以最后一个出现的组中启动项为准。

### 2.2 系统变量

多个单词用下划线连接；大部分系统变量可通过启动项设置，但有些只读的不能；系统变量的值可以在服务器程序运行时修改，不许停止重启。

#### 2.2.1 全局变量和会话变量

①服务器启动时，按照启动选项或默认值设置全局变量(启动项所设置的值对所有客户端有效)

②对每个客户端维持一组会话变量，会话变量使用相应的全局变量初始化

1. **运行时修改变量语法：**

   语法：SET [GLOBAL|SESSION] 系统变量名 = 值；SET [@@(GLOBAL|SESSION).]var_name = XXX;

   > 全局：SET GLOBAL default_storage_engine = MyISAM;
   >
   > SET @@GLOBAL.default_storage_engine = MyISAM;
   >
   > 局部：SET SESSION default_storage_engine = MyISAM;
   >
   > SET @@SESSION.default_storage_engine = MyISAM;
   >
   > SET default_storage_engine = MyISAM;

   如果在设置系统变量的语句中省略了作⽤范围， 默认的作⽤范围就是SESSION(SHOW查看的默认也是SESSION)

2. 注意：

   * 并不是所有系统变量都具有GLOBAL和SESSION的作⽤范围
   * 有些系统变量是只读的， 并不能设置值。 ⽐⽅说version

#### 2.2.2状态变量

⽤来显示服务器程序运⾏状况，只能由服务器程序⾃⼰来设置， 我们程序员是不能设置的

也有GLOBAL和SESSION

# 3. 字符集和⽐较规则

字符集、比较规则、关系、如何查看、四个级别及其修改、字符集替换过程、比较大小

### 3.1字符集、比较规则

#### 3.1.1 常见字符集

1. ASCII字符集：**共收录128个字符**， 包括空格、 标点符号、 数字、 ⼤⼩写字⺟和⼀些不可⻅字符。使⽤**1个字节**来进⾏编码

2. GB2312、GBK字符集：收录汉字、拉丁字母等，兼容ASCII字符集。**ASCII字符集中的字符占1字节，其他的占2字节**。GBK在收录字符上做了扩展。

3. utf字符集：收录地球上所有字符，变长编码，utf8使 ⽤1～4个字节编码⼀个字符；utf16使⽤2个或4个字节编码⼀个字符；utf32使⽤4个字节编码⼀个字符

   > MySQL中的utf8和utf8mb4：
   >
   > utf8mb3： 阉割过的utf8字符集， 只使⽤1～3个字节表示字符。
   >
   > utf8mb4： 正宗的utf8字符集， 使⽤1～4个字节表示字符。
   >
   > 在MySQL中utf8是utf8mb3的别名， 所以之后在MySQL中提到utf8就意味着使⽤1~3个字节来表示⼀个字符

#### 3.1.2 字符集查看

SHOW	(CHARACTER SET|CHARSET)	[LIKE 匹配的模式];

字符集的Maxlen(一个字符最多需几个字节)

>  ascii：1	latin1：1	gb2312/gbk：2	utf8:3	utf8mb4:4

#### 3.1.3  比较规则

SHOW COLLATION [LIKE 匹配的模式];

#### 3.1.4 字符集比较规则关系

* 在MySQL中，⼀个字符集可以有若⼲种⽐较规则， 其中有⼀个默认的⽐较规则，
* ⼀个⽐较规则必须对应⼀个字符集。

### 3.2 MySQL四个级别字符集和比较规则

服务器级别：character_set_server(字符集)	collation_server(比较规则)

数据库级别：character_set_database(字符集)	collation_database(比较规则)

表级别、列级别

#### 3.2.1 查和改

**查：**SHOW VARIABLES LIKE 'character_set_server'（或'collation_server'）;

**修改：**

1. **服务器**级别修改

* 启动服务器程序时通过启动选项
* 在服务器程序运⾏过程中使⽤SET语句修改这两个变量的值

2. **数据库**级别修改

* **创建**和**修改**数据库的时候可以指定该数据库的字符集和⽐较规则(前提是使⽤USE语句选择当前默认数据库， 如果没有默认数据库， 则变量与相应的**服务器级**系统变量具有相同的值)

~~~mysql
CREATE/ALTER DATABASE 数据库名 
	[[DEFAULT] CHARACTER SET 字符集名称] 
	[[DEFAULT] COLLATE ⽐较规则名称];
~~~

这两个系统变量是只读的， 我们不能通过修改这两个变量的值⽽改变当前数据库的字符集和⽐较规则。

3. **表级别**修改

* **创建**和**修改**表的时候指定表的字符集和⽐较规则。
* 如果创建和修改表的语句中没有指明字符集和⽐较规则， 将使⽤该表所在**数据库的字符集**和⽐较规则作为该表的字符集和⽐较规则

~~~mysql
CREATE/ALTER TABLE 表名
	[[DEFAULT] CHARACTER SET 字符集名称] 
	[COLLATE ⽐较规则名称]
~~~

4. **列级别**修改

* 存储字符串的列，**同⼀个表中的不同的列也可以有不同的字符集和⽐较规则**。
* 创建和修改列定义的时候可以指定该列的字符集和⽐较规则
* 对于某个列来说， 如果在创建和修改的语句中没有指明字符集和⽐较规则， 将使⽤该列所在表的字符集和⽐较规则作为该列的字符集和⽐较规则

**仅修改字符集或比较规则：**

二者相关联，会一起变

* 只修改字符集， 则⽐较规则将变为修改后的字符集默认的⽐较规则。 
* 只修改⽐较规则， 则字符集将变为修改后的⽐较规则对应的字符集。

### 3.3 客户端和服务器通信

> character_set_**client**：服务器**解码请求**时使⽤的字符集
>
> character_set_**connection**：服务器**处理请求**时使⽤的字符集
>
> character_set_**results**：服务器向客户端**返回数据**时使⽤的字符集

**通信流程：**

1. 客户端发送请求

2.1 服务器按照接受预设的字符集(character_set_client)接受字节码

2.2 服务器将接收到的字节码转换为服务器处理设置的字节码(character_set_connection)

2.3 如果处理设置的字节码与列使用的字符集不同，则转换为列所用字符集后进行处理

2.4 将查找结果使用列字符集解码，之后转换为返回结果设置的字符集(character_set_results)

3. 客户端将返回的结果字符集按照设置的接受字符集进行解码

* 2.1时，如果客户端发送的请求字符集与服务器预设不同，则服务器不能理解请求，更无法处理
* 3时，如果客户端不理解服务器字符集，则显示乱码

**设置字符集名：**

服务器端：SET NAMES 字符集名;(同时设置三个字符集)

客户端：default-character-set 系统变量

对某个字符串列做排序操作时没有得到想象中的结果， 需要思考⼀下是不是⽐较规则的问题～



# 4. InnoDB记录结构

### 4.1 简介

* 真实数据在不同存储引擎中存放的格式⼀般是不同的
* 页：InnoDB以页为单位，在磁盘和内存间进行数据调度，一般页为16KB
* 行：向表中插入数据是以行为单位的，这些行在磁盘上存储方式称行格式(记录格式)，InnoDB引擎到现在有4种不同类型的行格式Compact、 Redundant、 Dynamic和Compressed
* 创建或修改表的语句中指定⾏格式CREATE(或ALTER) TABLE 表名 ROW_FORMAT=⾏格式名称

### 4.2 行格式

#### 4.2.1 COMPACT行格式：

⼀条完整的记录其实可以被分为**记录的额外信息**和**记录的真实数据**两⼤部分

**记录的额外信息：**变⻓字段⻓度列表、NULL值列表、记录头信息

1. 变长字段长度列表：

   > 1. 变长字段存储空间分为：真正的数据内容+占用的字节数
   >
   > 2. 列表元素存放规则：变长字段真实数据占用的字节长度存放在记录的开头部分(即变长字段长度列表)，各变长字段数据占用的字节数**逆序**存放
   >
   > 3. 列表元素长度规则：如果该可变字段允许存储的最⼤字节数（M×W） 超过255字节并且真实存储的字节数（L） 超过127字节， 则使⽤2个字节， 否则使⽤1个字节。
   > 4. 变⻓字段⻓度列表中只存储值为 ⾮NULL 的列内容占⽤的⻓度， 值为 NULL的列的⻓度是不储存的
   > 5. 并不是所有记录都有这个 变⻓字段⻓度列表 部分， ⽐⽅说表中所有的列都不是变⻓的数据类型的话， 这⼀部分就不需要有。

2. NULL值列表：

   >  1. 处理过程：
   >
   >     ①⾸先统计表中允许存储NULL的列有哪些 
   >
   >     ②将每个允许存储NULL的列对应⼀个⼆进制位， ⼆进制位按照列的顺序逆序排列(1表示为NULL，0表示部位NULL)
   >
   >     ③MySQL规定NULL值列表必须⽤整数个字节的位表示， 如果使⽤的⼆进制位个数不是整数个字节， 则在字节的⾼位补0。

3. 记录头信息：

   > 固定的5个字节组成(40个比特位)
   >
   > (0)两个预留位，暂时没用到
   >
   > (1) delete_mask：标记此记录是否被删除。所有被删除的记录组成垃圾链表，链表中记录占用的空间称为可重用空间，有新记录时可能覆盖这些记录。
   >
   > (2) min_rec_mask：B+树的每层⾮叶⼦节点中的最⼩记录都会添加该标记
   >
   > (3) n_owned：槽记录指示本组中记录个数，其余记录为0
   >
   > (4) heap_no：表示当前记录在本页中的位置
   >
   > (5) record_type：表示当前记录的类型，普通记录、B+树⾮叶节点记录(目录项记录)、最⼩记录、最⼤记录
   >
   > (6) next_record：从当前记录的真实数据到下⼀条记录的真实数据的地址偏移量(下⼀条记录指得并不是按照我们插⼊顺序的下⼀条记录， ⽽是按照主键值由⼩到⼤的顺序的下⼀条记录)
   >
   > next_record指向记录**记录头信息**和**真实数据**中间，因为此位置向左读取就是记录头信息， 向右读取就是真实数据。且左边逆序排序，右边顺序排序。
   >
   > ![数据区实例](E:\java找工作\总结\java总结\图片\Mysql\数据区实例.png)
   > 

**记录的真实数据：**

1. InnoDB会在真实数据前添加隐藏列：(⾏ID)、事务ID、回滚指针
2. 已经在NULL值列表记录过的列，在真实数据处不会再冗余存储
3. 对CHAR(M)：如果用定长字符集，则在没存满的位置填空格；如果使用变长字符集，则将C3列长度存储到变长字段长度列表中

#### 4.2.2 Redundant、Dynamic、Compressed

1. 行溢出：⼀条记录的某个列中存储的数据占⽤的字节数⾮常多时， 该列就可能成为溢出列。

   > COMPACT、Redundant在本记录的真实数据处只会存储部分数据和⼀个 指向其他⻚的地址， 然后把剩下的数据存放到其他⻚中， 这个过程也叫做⾏溢出， 存储超出768字节的那些⻚⾯也被称为溢出⻚。
   >
   > Dynamic和Compressed⾏格式不会在记录的真实数据处存储部分字节， ⽽是把所有的字节都存储到其他⻚⾯中， 只在记录的真 实数据处存储其他⻚⾯的地址

2. Redundant：额外信息：字段长度偏移列表、记录头信息
3. Compressed⾏格式和Dynamic不同的⼀点是， Compressed⾏格式会采⽤压缩算法对⻚⾯进⾏压缩， 以节省空间。

### 4.3 索引页结构

存放记录的页称为索引页(数据页)

数据页各个部分内容

![image-20200512003544299](E:\java找工作\总结\java总结\图片\Mysql\数据区各部分内容.png)

1. User Records：存储的记录会按照指定的行格式存入User Records。

   > 插入记录时会从Free Space申请内存
   >
   > 删除一条记录A时：①记录A的delete_mask值设置为1②记录A的next_record值变为了0③A的上一条记录的next_record指向A的下一条④维护此组的n_owned
   >
   
2. Infimum + Supremum：最小记录+最大记录，按照主键大小比较，5字节记录头信息+8字节固定部分(heap_no分别为0、1)

3. Page Directory(页目录)：类似书本的章节，对数据进行划分

   > **页目录构成**：
   >
   > 1. 将所有正常的记录（包括最⼤和最⼩记录，不包括标记为已删除的记录） 划分为⼏个组。
   >
   >    **分组规则**： 
   >
   >    ​	(1)初始情况下⼀个数据⻚⾥只有最⼩记录和最⼤记录两条记录， 它们分属于两个分组
   >
   >    ​	(2)每插⼊⼀条记录， 都会从⻚⽬录中找到主键值⽐本记录⼤并且差值最⼩的槽，之后将槽对应记录的n_owned+1
   >
   >    ​	(3)在⼀个组中的记录数等于8个后再插⼊⼀条记录时， 会将组中的记录拆分成两个组，⼀个组中4条记录， 另⼀个5条记录。 且会在⻚⽬录中新增⼀个槽来 记录这个新增分组中最⼤的那条记录的偏移量
   >
   > 2. 每个组的最后⼀条记录（也就是组内最⼤的那条记录） 的头信息中的n_owned属性表示该记录拥有多少条记录， 也就是该组内共有⼏条记录。
   >
   > 3. 将每个组的最后⼀条记录的地址偏移量单独提取出来按顺序存储到靠近⻚的尾部的地⽅， 这个地⽅就是所谓的Page Directory，⻚⾯⽬录中的这些地址偏移量被称为槽。⻚⾯⽬录就是由槽组成的
   >
   > 快速查找：
   >
   > (1)通过**⼆分法**确定该记录所在的槽， 并找到该槽中主键值最⼩的那条记录
   >
   > (2)通过记录的next_record属性**遍历**该槽所在的组中的各个记录

4. Page Header：56字节，记录此数据页的状态信息，如存了多少条记录，多少个槽等

   > (1) PAGE_DIRECTION：假如新插⼊的⼀条记录的主键值⽐上⼀条记录的主键值⼤， 我们说这条记录的插⼊⽅向是右边， 反之则是左边。
   >
   > (2) PAGE_N_DIRECTION：假设连续⼏次插⼊新记录的⽅向都是⼀致的， InnoDB会把沿着同⼀个⽅向插⼊记录的条数记下来，即PAGE_N_DIRECTION

5. File Header(文件头部)(类型的⻚通⽤)

   > FIL_PAGE_SPACE_OR_CHKSUM：当前⻚⾯的校验和
   >
   > FIL_PAGE_OFFSET：每⼀个⻚都有⼀个单独的⻚号，InnoDB通过⻚号来可以唯⼀定位⼀个⻚，和偏移差不多，更接近物理。
   >
   > FIL_PAGE_TYPE：代表当前⻚的类型
   >
   > FIL_PAGE_PREV和FIL_PAGE_NEXT：分别代表本⻚的上⼀个和下⼀个⻚的⻚号(并不是所有类型的⻚都有上⼀个和下⼀个⻚的属性)所有的数据⻚其实是⼀个双链表

6. File Trailer：检测⼀个⻚是否完整(类型的⻚通⽤)

   > 前4个字节代表⻚的校验和(完全同步成功， 则⻚的⾸部和尾部的校验和应该是⼀致的，⼆者不同则意味着同步中间出了错。)、后4个字节代表⻚⾯被最后修改时对应的⽇志序列位置（LSN）

p.s. 所有的数据⻚会组成⼀个双链表，数据⻚中的所有记录串联成⼀个单链表

# 5. 索引

### 5.1 B+树索引

#### 5.1.1 无索引查找

1. 在一个页中的查找

   以主键为搜索条件：可在页目录中使用二分法定位槽，之后遍历槽对应分组中的记录

   以其他列为条件：无法定位槽，只能从最小记录遍历整个页中记录

2. 在多个页中查找

   ①定位记录所在的页，②从页中查找相应记录

   没有索引的话，定位数据页需要遍历所有页，页中查找记录按上述方式查找。

#### 5.1.2 有索引查找

   **索引**：快速定位记录所在的**数据⻚**⽽建⽴⼀个⽬录

> **索引的要求：**
>
> 1. 下⼀个数据⻚中⽤户记录的主键值必须⼤于上⼀个页中⽤户记录的主键值。(需要移动记录等操作叫页分裂)
> 2. 给所有页建立目录项

​	**目录项：**⻚的⽤户记录中最⼩的主键值(key)+页号(page_no)(记录头信息⾥的record_type==1即为目录项)

> 目录项记录与用户记录不同：①record_type ②⽬录项记录只有主键值和⻚的编号两个列 ③一个存储目录项的页内，最小主键值的目录项记录min_rec_mask==1，其余为0
>
> 目录项记录与用户记录相同：①使用数据页，页的组成结构、生成的页目录、查找记录的方法都一样
>
> 当目录项存储于多个页中时，**查找用户记录过程**：①确定目录项记录所在的页②通过目录项记录确定用户记录所在的页③在页中寻找具体记录

**B+树：**所有⽤户记录都存储在B+树的叶⼦节点(第0层)， 所有⽬录项记录都存储在内节 点

**聚簇索引：**InnoDB存储引擎会⾃动的为我们创建聚簇索引。在InnoDB存储引擎中， 聚簇索引就是数据的存储 ⽅式（所有的⽤户记录都存储在了叶⼦节点），索引即数据， 数据即索引

> **特点**：1. 使⽤记录**主键值**的⼤⼩进⾏记录和⻚的排序
>
> ​				①页内记录按照主键⼤⼩排成单向链表
>
> ​				②各个存放⽤户记录的⻚根据页中用户记录的主键大小排成双向链表
>
> ​				③B+树中，同一层次的页根据页中目录项记录的主键大小排成双向链表
>
> ​			2. B+树的叶⼦节点存储的是完整的⽤户记录

**二级索引：**⼆级索引的叶⼦节点包含的⽤户记录由索引列 + 主键组成，需要回表

> 聚簇索引与二级索引**区别**：(以C2列建立索引)
>
> 1. 三层排序是按照**c2**的大小进⾏记录和⻚的排序
>
> 2. B+树的叶⼦节点存储的并不是完整的⽤户记录， ⽽只是c2列+主键这两个列的值
>
> 3. ⽬录项记录中不再是主键+⻚号的搭配， ⽽变成了c2列+⻚号的搭配
>
> 根据C2查找记录过程：
>
> 1. 确定⽬录项记录⻚
> 2. 通过⽬录项记录⻚确定⽤户记录真实所在的⻚。
> 3. 在真实存储⽤户记录的⻚中定位到具体的记录(只存储了C2+主键)。
> 4. 根据主键值去聚簇索引中再查找⼀遍完整的⽤户记录(回表)

**联合索引：**同时以多个列的⼤⼩作为排序规则

> 1. 每条**⽬录项**记录都由c2、 c3、 ⻚号这三个部分组成， 各条记录先按照c2列的值进⾏排序， 如果记录的c2列相同， 则按照c3列的值进⾏排序。 
> 2. B+树**叶⼦节点**处的⽤户记录由c2、c3和主键c1列组成。

**注意事项：**

> 1. ⼀个B+树索引的根节点⾃诞⽣之⽇起， 便不会再移动。 
>
> 2. 需要保证在B+树的同⼀层内节点的⽬录项记录除⻚号这个字段以外是唯⼀的e.g.二级索引：**索引列的值、主键值**、⻚号
>
> 3. InnoDB的⼀个数据⻚⾄少可以存放两条记录
>
> 4. InnoDB中索引即数据，即B+树的叶子节点已包含完整的用户记录
>
> 5. MyISAM索引与数据分开①将表中的记录按照记录的**插⼊顺序**单独存储在⼀个⽂件中， 称之为数据⽂件(不分页)②索引信息另外存储到⼀个称为索引⽂件的另⼀个⽂件③MyISAM会单独为表的主键创建⼀个索引，主键值 + ⾏号的组合。 也就是先通过索引找到对应的⾏号， 再通过⾏号去找对应的记录
>
> 6. 创建、修改表时指定索引

### 5.2 索引的使用

#### 5.2.1 索引适用条件：

1. 全值匹配：搜索条件中的列和索引列⼀致

2. 匹配左边的列：如果我们想使⽤联合索引中尽可能多的列， 搜索条件中的各个列必须是联合索引中从最左边连续的列

   > e.g.索引为idx_name_birthday_phone，如果使用name和phone进行查询，则phone是无序的，只利用到了name的索引

3. 匹配列前缀：使用LIKE查询时，如果使用索引，则字符串的前缀都是排好序的，可以加快查找

   > 如果只给出后缀或者中间的某个字符串，⽆法快速定位记录位置，只能全表扫描
   >
   > 匹配后缀时，数据逆序存储，之后匹配前缀。

4. 匹配范围值：使用> <号查询时

   > 1. 如果对多个列同时进⾏范围查找的话， 只有对索引最左边的那个列进⾏范围查找的时候才能⽤到B+树索引；对其他的列进行范围查找时无法使用索引。(因为整体不是有序的)
   > 2. 如果左边的列是精确查找， 则右边的列可以进⾏范围查找

5. 用于排序：ORDER BY

   > 1. ORDER BY的⼦句后边的列的顺序也必须按照索引列的顺序给出
   > 2. 对于使用多个列进行排序，要么各个列都是ASC规则排序， 要么都是DESC规则排序，否则不能使用索引
   > 3. 如果WHERE⼦句中出现了⾮排序使⽤到的索引列， 则不能使用索引
   > 4. 如果ORDER BY子句中有列不是索引列，则不能用索引
   > 5. ORDER BY中的列是索引列，且没有运算和函数，才可以使用索引

6. 用于分组：情况和排序类似

#### 5.2.2 索引注意事项

1. 为减少回表带来的性能损耗，最好在SELECT列表⾥只包含索引列(只需要⽤到索引的查询⽅式称为索引覆盖)

2. 选择索引时：

   > (1)只为出现在WHERE⼦句中的列、 连接⼦句中的连接列， 或者出现在ORDER BY或GROUP BY⼦句中的列创建索引
   >
   > (2)最好为那些列的基数⼤的列 建⽴索引， 为基数太⼩列的建⽴索引效果可能不好
   >
   > (3)索引列的类型尽量⼩
   >
   > (4)推荐只对字符串的前⼏个字符进⾏索引
   >
   > (5)让索引列在⽐较表达式中单独出现，如果索引以表达式、函数调用出现，则无法使用索引
   >
   > (6)建议让主键具有AUTO_INCREMENT， 让存储引擎⾃⼰为表⽣成主键， ⽽不是我们⼿动插⼊(插入的话会导致后面的列移动，影响效率)
   >
   > (7)避免重复索引、冗余索引

# 6. MySQL存储

### 6.1 数据目录

1. MySQL服务器启动和运行时会加载此目录下文件，其文件类型主要有：

2. **数据库**表示：每个数据库都对应数据⽬录下的⼀个⼦⽬录， 或者说对应⼀个⽂件夹

   > 创建数据库时：
   > 1. 在数据⽬录下创建⼀个和数据库名同名的⼦⽬录（或者说是⽂件夹）
   > 2. 在该与数据库名同名的⼦⽬录下创建⼀个名为db.opt的⽂件， 这个⽂件中包含了该数据库的各种属性

3. **表**的表示：

   > 1. 表结构定义：对应的数据库⼦⽬录下创建了⼀个专⻔⽤于描述表结构的⽂件(表名.frm)
   >
   > 2. 表中数据：表空间、文件空间(表空间是⼀个抽象的概念， 它可以对应⽂件系统上⼀个或多个真实⽂件)
   >
   >    InnoDB：
   >
   >    ​	(1)系统表空间：在⼀个MySQL服务器中， 系统表空间只有⼀份。MySQL某些版本中表中的数据都会被默认存储到系统表空间。
   >
   >    ​	(2)独立表空间：为每⼀个表建⽴⼀个独⽴表空间，在此表所属数据库的子文件夹下
   >
   >    MyISAM：表数据都存放到对应的数据库⼦文件夹下

4. 视图表示：视图所属数据库子文件夹下，保存视图的结构

5. 其他文件：服务器进程⽂件、服务器日志⽂件、证书和秘钥文件

6. MySQL系统数据库：

   > 1.mysql：存储MySQL账户、存储过程、时区等信息
   >
   > 2.information_schema：保存着所有其他数据库的信息，有哪些表、列、视图等
   >
   > 3.performance_schema：保存MySQL服务器运⾏过程中的⼀些状态信息
   >
   > 4.sys：通过视图的形式把information_schema和performance_schema结合起来

### 6.2 表空间

#### 6.2.0 前提概念

1. **区：** 物理位置上**连续的**64个页就是一个**区**

   > 区的状态：
   >
   > * 属于表空间：空闲的区(FREE)、有剩余空间的碎片区(FREE_FRAG)(区中有可用页面)、没有剩余空间的碎片区(FULL_FRAG)
   > * 属于某个段：附属于某个段的区(FSEG)

2. **组：**256区划为一个**组**

3. **段：**存放叶子节点区的集合是一个段，存放非叶子节点区的集合是一个段。⼀个索引会⽣成2个段，⼀个叶⼦节点段，⼀个⾮叶⼦节点段

   > 段其实不对应表空间中某⼀个连续的物理区域， ⽽是⼀个逻辑上的概念， 由若⼲个零散的⻚⾯以及⼀些完整的区组成。
   >
   > 分配空间策略：(1)一开始段从碎片区中以单个页面为单位分配存储空间(2)某个段占用32个碎片区页面后，以完整的区分配

4. **碎片区：**段以区为单位申请存储空间，碎片区可以让很多段存在碎片区中。

   > 碎⽚区直属于表空间， 并不属于任何⼀个段

5. **XDES Entry结构**：每⼀个区都对应着⼀个XDES Entry结构

   > Segment ID：表示就是该区所在的段(前提是该区已经被分配给某个段)
   >
   > List Node：将若⼲个XDES Entry结构串联成⼀个链表
   >
   > State：此区的状态，四选一
   >
   > Page State Bitmap：每两个比特表示一个页面是否空闲
   
6. **XDES Entry链表：**使用上述List Node中指向前驱后继的指针构成

   >1. XDES Entry链表：(直属表空间、属于每个段的各有三个链表)
   >
   >   (1) 状态为FREE的区通过List Node来连接成⼀个链表，称FREE链表
   >
   >   (2) 状态为FREE_FRAG的区通过List Node来连接成⼀个链表，称FREE_FRAG链表
   >
   >   (3) 状态为FULL_FRAG的区通过List Node来连接成⼀个链表，称FULL_FRAG链表
   >
   >      e.g.两个索引--->4个段--->3个直属表空间+12个各段的链表
   >
   >2. 分配时：①找FREE_FRAG链表的头节点，从此节点取一些零碎的页插入数据，当次节点对应的区用完时，修改此区的State，从FREE_FRAG链表中移到FULL_FRAG链表中
   >
   >   ②如果FREE_FRAG链表中⼀个节点都没有，就从 FREE链表中取⼀个节点移动到FREE_FRAG链表，并修改该节点的STATE字段值为FREE_FRAG，然后从这个节点对应的区中获取零碎的⻚
   >
   >3. 每个链表都对应这么⼀个List Base Node结构，记录了链表的头、 尾节点的位置以及该链表中包含的节点数
   
7. **INODE Entry结构**：每个段都定义了⼀个INODE Entry结构来记录⼀下段中的属性

   > Segment ID：这个INODE Entry结构对应的段的编号
   >
   > NOT_FULL_N_USED：记录NOT_FULL链表已经使用多少页面，下次获取从NOT_FULL分配空闲页面时进行定位
   >
   > 3个List Base Node：分别为段的FREE链表、 NOT_FULL链表、 FULL链表定义了List Base Node
   >
   > Magic Number：标记这个INODE Entry是否已经被初始化了
   >
   > Fragment Array Entry：每个Fragment Array Entry结构都对应着⼀个零散的⻚⾯，记录页号
   
8. **Segment Header结构**：记录每个索引指向的INODE Entry结构

   > ⼀个索引只对应两个段， 所以只需要在索引的根⻚⾯中记录
   >
   > * 叶⼦节点段对应的INODE Entry结构的地址是哪个表空间的哪个⻚⾯的哪个偏移量
   > * 非叶⼦节点段对应的INODE Entry结构的地址是哪个表空间的哪个⻚⾯的哪个偏移量

9. **InnoDB数据字典**：InnoDB为存储元数据定义的一些内部**系统表**

   > 元数据：某个表里有多少列，有多少索引，有哪些外键等额外信息。
   >
   > 基本系统表：SYS_TABLES、 SYS_COLUMNS、 SYS_INDEXES、 SYS_FIELDS
   >
   > e.g.想查看SYS_TABLESPACES的元数据
   >
   > 1. 到SYS_TABLES表中根据表名定位到具体的记录， 就可以获取到目标表的TABLE_ID
   > 2. 使⽤这个TABLE_ID到SYS_COLUMNS表中就可以获取到属于该表的所有列的信息
   > 3. 使⽤这个TABLE_ID还可以到SYS_INDEXES表中获取所有的索引的信息(包括INDEX_ID)
   > 4. 使⽤INDEX_ID就可以到SYS_FIELDS表中获取所有索引列的信息

10. Data Dictionary Header页面：

    > 存放基本系统表的元数据信息

#### 6.2.1 各类型页面

第⼀个组最开始的3个⻚⾯的类型是固定的：

1. FSP_HDR：登记整个表空间的⼀些整体属性以及本组所有的区，整个表空间只有⼀个FSP_HDR类型的⻚⾯

   > * 直属于表空间的FREE链表的基节点、 FREE_FRAG链表的基节点、 FULL_FRAG链表的基节点
   > * XDES Entry部分
   > * 等

2. IBUF_BITMAP类型：存储本组所有的区的所有⻚⾯关于INSERT BUFFER的信息

3. INODE类型：存储了许多称为INODE的数据结构

   > INODE链表：
   >
   > * SEG_INODES_FULL链表： 该链表中的INODE类型的⻚⾯中已经没有空闲空间来存储额外的INODE Entry结构了。 
   > * SEG_INODES_FREE链表： 该链表中的INODE类型的⻚⾯中还有空闲空间来存储额外的INODE Entry结构了。
   >
   > 每当新创建⼀个段（创建索引时就会创建段） 时， 都会创建⼀个INODE Entry结构与之对应
   >
   > 1. 先看看SEG_INODES_FREE链表是否为空， 如果不为空， 直接从该链表中获取⼀个节点， 也就相当于获取到⼀个仍有空闲空间的INODE类型的⻚⾯， 然后把该 INODE Entry结构放到该⻚⾯中。 当该⻚⾯中⽆剩余空间时， 就把该⻚放到SEG_INODES_FULL链表中。
   > 2. 如果SEG_INODES_FREE链表为空， 则需要从表空间的FREE_FRAG链表中申请⼀个⻚⾯， 修改该⻚⾯的类型为INODE， 把该⻚⾯放到SEG_INODES_FREE链表中，与 此同时把该INODE Entry结构放⼊该⻚⾯。

其余各组最开始2个页面类型是固定的：

1. XDES类型：与FSP_HDR类型，只是少了表空间一些属性
2. IBUF_BITMAP

### 6.2.2 系统表空间

系统表空间和独⽴表空间的前三个⻚⾯（⻚号分别为0、 1、 2， 类型分别是FSP_HDR、 IBUF_BITMAP、 INODE） 的类型是⼀致的。⻚号为3～7的⻚⾯ 是系统表空间特有的。

> 3~7保存元数据，为管理用户数据引入的额外数据，存入系统表中，这些系统表被称为数据字典

# 7. 访问

### 7.1 单表访问

1. 全表扫描

2. 使用索引查询

   > (1)const：针对**主键或唯⼀⼆级索引**的**等值查询**
   >
   > ​	如果主键或者唯⼀⼆级索引是由多个列构成的话， 索引中的每⼀个列都需要与常数进⾏等值⽐较
   >
   > ​	如果查询key is null 则不能用const，因为可能对应多个
   >
   > <img src="E:\java找工作\总结\java总结\图片\Mysql\const.png" alt="const" style="zoom: 80%;" />
   >
   > (2)ref：针对**普通⼆级索引**的**等值查询**(ref)(不唯一，返回多个记录)
   >
   > ​	对于某个包含多个索引列的⼆级索引，如果最左边的连续索引列并不全部是等值⽐较的话， 其访问⽅法就不能称为ref
   >
   > ​		①：使⽤⼆级索引定位记录，从索引所在的B+树中找到对应的二级索引记录
   >
   > ​		②：回表，根据①得到的记录去聚簇索引中寻找完整的用户记录
   >
   > <img src="E:\java找工作\总结\java总结\图片\Mysql\ref.png" alt="ref" style="zoom:80%;" />
   >
   > 
   >
   > (3)ref or null：不仅想找出某个⼆级索引列的值等于某个常数的记录， 还有该列的值为NULL的记录
   >
   > (4)range：针对索引列的范围查询
   >
   > (5)index：select的东西和where的东西都在索引列里，可以遍历二级索引记录
   >
   > (6)all：全表扫描

### 7.2 多表访问

内连接： **驱动表**中的记录在**被驱动表**中找不到匹配的记录， 该记录不会加⼊到最后的结果集

外连接：**驱动表**中的记录即使在**被驱动表**中没有匹配的记录， 也仍然需要加⼊到结果集。

> 左外连接(LEFT JOIN)：左侧的表为驱动表，右外连接(RIGHT JOIN)：右侧的表为驱动表

ON子句：对于外连接说， 如果⽆法在**被驱动表**中找到匹配ON⼦句中的过滤条件的记录， 那么该记录仍然会被加⼊到结果集中， 对应的被驱动表记 录的各个字段使⽤NULL值填充。

> 对内连接来说，ON和where功能一样

#### 7.2.1 连接过程

1. 确定驱动表，并在驱动表中根据单表查询，查询满足where的记录

2. 根据第一步查到的记录，逐个到被驱动表中进行过滤查找

   > (1)当t1.m1 = 2时， 过滤条件t1.m1 = t2.m2就相当于t2.m2 = 2， 所以此时t2表相当于有了t2.m2 = 2、 t2.n2 < 'd'这两个过滤条件， 然后到t2表中 执⾏单表查询。
   >
   > (2)当t1.m1 = 3时， 过滤条件t1.m1 = t2.m2就相当于t2.m2 = 3， 所以此时t2表相当于有了t2.m2 = 3、 t2.n2 < 'd'这两个过滤条件， 然后到t2表中 执⾏单表查询。

#### 7.2.2 连接原理

嵌套循环连接：**驱动表**只访问⼀次， 但**被驱动表**访问次数取决于对驱动表查询的记录条数的连接执⾏⽅式

基于块的嵌套循环链接：扫描表时，首先将表从磁盘加载到内存，之后在内存中匹配条件是否满足。所以可以通过减少访问被驱动表次数来优化。e.g. 被驱动表的记录加载到内存的时候，⼀次性和多条驱动表中的记录做匹配

join buffer：驱动表结果集中若干记录存于join buffer，被驱动表每条记录和join buffer 中多条记录做匹配。

> 只存SELECT 和WHERE子句中的列

### 7.3 基于成本的优化

1. I/O成本：从磁盘加载到内存(读取一个页面)，默认0.1

2. CPU成本：读取以及检测记录记录是否匹配等操作，默认0.2

3. 优化步骤：

   > (1)计算全表扫描代价：此表聚簇索引所占页面数+表中记录数
   >
   > (2)计算所有可能使用的索引代价：e.g.：
   >
   > ​	驱动表中确定记录所在页面，(如范围区间的个数或单点的点数) * 1
   >
   > ​	读取驱动表记录的CPU成本 记录数 * 0.2
   >
   > ​	每条记录进行回表，读取页面：记录数 * 1
   >
   > ​	读取聚簇索引，并检测：记录数 * 0.2
   >
   > (3)比较，选择最小的

4. 扇出：对**驱动表**进行查询后得到的记录条数

5. 连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

6. 连接优化：

   > 外连接：分别对驱动表和被驱动表选择成本最低访问方法
   >
   > 内连接：(1)确定标的最优连接顺序(2)分别对驱动表和被驱动表选择成本最低访问方法
   >
   > 优化方法：尽量在被驱动表的连接列上建⽴索引

7. 调节成本函数：

   > mysql.server_cost表存储server层变量
   >
   > mysql.engine_cost表存储引擎层变量

### 7.4 InnoDB收集统计数据

1. 永久性数据：将统计数据存入innodb_table_stats，innodb_index_stats表中

   > innodb_table_stats表的每条记录代表着⼀个表的统计信息(其中数据为估计值)
   >
   > ​	n_rows：表中的行数估计值，计算几个页面平均记录数，之后乘页面数
   >
   > ​	clustered_index_size：表的聚簇索引占⽤的⻚⾯数量
   >
   > ​	sum_of_other_index_sizes：表的其他索引占⽤的⻚⾯数量
   >
   > innodb_index_stats表的每条记 录代表着⼀个索引的⼀个统计项。
   >
   > ​	主键是(database_name,table_name,index_name,stat_name)
   >
   > 默认变化超过表数据10%时，会自动更新(检测到超过10%有延迟)
   >
   > 手动执行命令，立即更新

2. 非永久性数据：经常变化，不过用的少

# 8.MySQL基于规则优化

查询重写的规则

### 8.1 条件简化

①移除不必要的括号 ②常量替换 ③溢出没用的条件 ④表达式中参数先计算出来 ⑤HAVING和WHERE合并

⑥外连接消除

> 常量表检测：所查询记录不存在和只有一条；使用主键或唯一二级索引的等值匹配
>
> 空值拒绝：外连接查询中，被驱动表的条件显示或隐式包含不为NULL的条件成空值拒绝。被驱动表中WHERE子句符合空值拒绝的条件，内外连接可相互转换

### 8.2 子查询优化

标量子查询(1\*1)行子查询(返回一行)列子查询(返回一列)表子查询(返回n\*n)

不相关子查询(子查询可单独运行出结果)、相关子查询(子查询需依赖外层查询)

**SELECT子句中：**无意义

**FROM子句中**：派生表

**WHERE/ON子句中**：

1. IN子查询优化：

   >  建立物化表：存储子查询结果(列为子查询结果集中的列)(去重)(数据小时Memory引擎，数据大时使用磁盘存储引擎)
   >
   > 将子查询转为半连接：(半连接指连接时，只关心被驱动表是否有与驱动表查询记录匹配的，不关心多少条)
   
   (1)**如果IN⼦查询符合转换为semi-join的条件， 查询优化器会优先把该⼦查询转换为semi-join**， 然后从*Table pullout、DuplicateWeedout、LooseScan、Materialization、FirstMatch***选择成本最低的策略执行子查询**。
   
   (2)如果IN⼦查询不符合转换为semi-join的条件，优化器会**"先将⼦查询物化之后再执⾏查询"**、**"执⾏IN to EXISTS转换"**两者中选择成本低的执行

# 9.Explain详解

EXPLAIN语句输出的每条记录 都对应着某个单表的访问⽅法

1. table：代表记录对应的表名

2. id：查询语句中的每个SELECT分配一个唯一id值。

   > SELECT的连接查询，每个表对应⼀条记录， 但是这些记录的id值都相同的。前面驱动表，后面被驱动表

3. SELECT_TYPE：SELECT 方法，如SIMPLE、PRIMARY、UNION等

   > SIMPLE(不含UNION和子查询)
   >
   > PRIMARY(UNION或子查询，最左边的查询为PRIMARY，其他为UNION)

4. type：Mysql对表查询时访问方法，如system、const、eq_ref、ref、All等

5. possible_keys和key：查询时可能用到的索引、经比较实际用到的索引

6. key_len：对某索引查询时，此索引最大长度

7. ref：使用等值匹配查询时，表示与索引列等值匹配的对象

   > 常数时为const、列时为：数据库名.表名.列名

8. rows：全表扫描时为预计扫描的行数；使用索引时为预计扫描的索引记录行数

9. filtered：

10. Extra：额外信息

# 10.BufferPool

使用InnoDB查询时，即使只访问某个页中一条记录，也需要先把整个也加载入内存。

访问完后，并不急着释放该页所占内存空间，而是将其缓存，之后有请求再访问同一页面，便可省去I/O。

1. Buffer Pool内存空间：控制块+缓存页+碎片

   > 控制块和缓存⻚是⼀⼀对应的，控制块集中在前面存储，缓冲页集中在后面存储
   >
   > 控制块：存放每个缓存页对应的控制信息
   > 缓存页：和磁盘中的页大小相同
   > ![缓冲池](E:\java找工作\总结\java总结\图片\Mysql\缓冲池.png)

2. 使用的链表：

   > (1)free链表：初始化后，将所有空闲缓存页对应的控制块作为节点。
   >
   > ​						基节点包含链表头、尾结点地址、当前链表中节点数量。不在Buffer Pool中，是单独申请
   >
   > (2)flush链表：脏页对应的控制块作为节点。脏页：Buffer Pool中的页经修改后与磁盘不同
   >
   > (3)LRU链表：最近最少使用。分为young区域(热数据，用的多)、old区域(冷数据，用的少)
   >
   > ​						从磁盘加载某个页面时，首先放入old区域头部
   >
   > ​						对old区域访问时，如果间隔在某区间内，则不动，如果间隔大于某阈值，则移到young

3. 缓存页的哈希：表空间号+页号是key、缓存页是value

4. chunk：每个Buffer Pool实例由若⼲个chunk组成，每⼀个Buffer Pool实例 中包含的chunk数量相同

5. 参数：

   > innodb_buffer_pool_size：缓冲区大小		innodb_old_blocks_pct：old区域比例
   >
   > innodb_buffer_pool_instances：Buffer Pool个数

6. 查看Buffer Pool状态：SHOW ENGINE INNODB STATUS

# 11.事务

ACID：需要保证原⼦性、 隔离性、 ⼀致性和持久性的⼀个或多个数据库操作称之为⼀个事务

事务的状态：活动的、部分提交的、失败的、终止的、提交的

![事务状态](E:\java找工作\总结\java总结\图片\Mysql\事务状态.png)

> 开启事务：BEGIN、START TRANSACTION
>
> 提交事务：COMMIT 	终止事务：ROLLBACK
>
> 自动提交：每条语句算一个独立的事务(BEGIN、START TRANSACTION破坏或设置为off)
>
> 隐式提交：非自动提交时，使用DDL、修改数据库中表、有事务、锁的语句
>
> 保存点：SAVEPOINT 保存点名称

### 11.1 redo日志

为保持永久性，且避免每次事务提交时修改全部页面到磁盘。使用redo日志将修改记录。

> 让已经提交了的事务对数据库中数据所做的修改永久⽣效， 即使系统崩溃， 在重启后也能把这种修改恢复出来。没有必要在每次事务提交时就把该事务在内存中修改过的全部⻚⾯刷新到磁盘， 只需要把修改了哪些东⻄记录⼀下就好。

只需将此记录刷新到磁盘

### 11.3 事务隔离级别

1. **问题**：脏读、丢失修改、不可重复读(两次读到数据不一样，被修改)、幻读(后一次读的记录多了些)

2. **隔离级别**：READ UNCOMMITTED(未提交读)、READ COMMITTED(已提交读)、REPEATABLE READ(可重复读)、SERIALIZABLE(可串行化)

   > 丢失修改过于严重，所有隔离级别都不允许丢失修改发生
   >
   > 在READ UNCOMMITTED隔离级别下， 脏读、 不可重复读、 幻读都可能发⽣。 
   >
   > 在READ COMMITTED隔离级别下， 不可重复读、 幻读可能发⽣， 脏读不可以发⽣。 
   >
   > 在REPEATABLE READ隔离级别下， 幻读可能发⽣， 脏读和不可重复读不可以发⽣。
   >
   > 在SERIALIZABLE隔离级别下，上述问题都不可以发⽣

3. **设置**：SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;对之后产生的会话生效

   ​		SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;对当前会话里后续事务生效

   ​		SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 只对当前回话下一个事务生效

4. **原理**：

   > 0. 每个聚簇索引记录包含trx_id字段(对此记录改动的事务id)、roll_pointer字段(指向上一个版本)
   >
   >    每次对一个记录改动，会记录一条undo日志，将其连起来，串成链表，称，如下<img src="E:\java找工作\总结\java总结\图片\Mysql\undo日志链表.png" alt="undo日志链表" style="zoom:50%;" />
   >
   > 1. ReadView：用于判断版本链中哪个版本是当前事务可见。
   >
   >    ​		**m_ids**：生成ReadView时活跃的事务id列表
   >
   >    ​				(被访问记录的**trx_id**位于min_trx_id~max_trx_id时，如果生成记录的事务trx_id在m_ids列表中，表示当前事务生成ReadView时，该事务还是活跃的，不能访问；反之如果不在列表中，表示生成记录的事务已提交，可以访问)
   >
   >    ​		**min_trx_id**：m_ids里的最小值
   >
   >    ​				(被访问记录的**trx_id**<ReadView的min_trx_id时，表示生成记录的事务在当前事务生成ReadView前提交，可以被当前事务访问)
   >
   >    ​		**max_trx_id**：生成ReadView时刻，如果生成下一个事务应给其分配的id
   >
   >    ​				(被访问记录的**trx_id**>ReadView的max_trx_id时，表示生成记录的事务在当前事务生成ReadView后才开启，不可以被当前事务访问)
   >
   >    ​		**creator_trx_id**：生成此ReadView的事务id
   >
   >    ​				(被访问记录的**trx_id**等于ReadView的creator_trx_id时，表示此事务访问其修改的记录，可以被此事务访问)
   >
   >    ​		如果某个版本的数据对当前事务不可见时，顺着版本链找下一版本，直至第一个可见的。如果一个都没有表示此记录对事务完全不可见，结果中不包含此记录
   >
   > 2. READ COMMITTED —— 每次读取数据前都⽣成⼀个ReadView(每个select)
   >
   > 3. REPEATABLE READ —— 在第⼀次读取数据时⽣成⼀个ReadView(不同的事务共用一个ReadView)

# 12. 锁

1. 锁结构

   > trx：此锁结构是哪个事务生成，is_waiting：当前事务是否在等待

2. 解决脏读等问题：

   > (1) 读操作利⽤多版本并发控制（MVCC）， 写操作进⾏加锁
   >
   > (2) 读、 写操作都采⽤加锁的⽅式

3. 一致性读、锁定读

   > (1)一致性读：事务利⽤MVCC进⾏的读取操作。也叫快照读、一致性无锁读，SELECT在READ COMMITTED、 REPEATABLE READ级别下
   >
   > (2)锁定读：
   >
   > ​	共享锁：S锁		SELECT ... LOCK IN SHARE MODE
   >
   > ​	独占锁：X锁		SELECT ... FOR UPDATE

4. 意向锁

   > IS锁，当事务准备在某条记录上加S锁时， 需要先在表级别加⼀个IS锁
   >
   > IX锁，当事务准备在某条记录上加X锁时， 需要先在表级别加⼀个IX锁
   >
   > IS/IX两两之间都是兼容的，只标记一下

5. MyISAM、MEMORY、MERGE仅支持表级锁，不支持事务，锁针对的是事务

6. InnoDB：

   > 1. 表级锁：
   >
   >    S锁、X锁；IS、IX锁；AUTO-INC锁
   >
   >    ​		⾃动给AUTO_INCREMENT修饰的列递增赋值的原理：
   >
   >    ​				(1)不确定插入记录数目时，采⽤AUTO-INC锁，⼀个事务在持有AUTO-INC锁的过程中， 其他事务的插⼊语句都要被阻塞， 可以保证⼀个语句中分配 的递增值是连续的
   >
   >    ​				(2)可以确定具体插入记录数：采⽤⼀个轻量级的锁， 在为插⼊语句⽣成AUTO_INCREMENT修饰的列的值时获取⼀下这个轻量级锁， 然后⽣成本次插⼊语句需要⽤到的 AUTO_INCREMENT列的值之后， 就把该轻量级锁释放掉
   >
   > 2. 行级锁：
   >
   >    Record Locks：仅对一条记录上锁，分X锁、S锁
   >
   >    Gap Locks：对(上一条记录~此记录)上锁，仅为防止幻影记录，因此可以加好多gap锁
   >
   >    ​				如果你对⼀条记录 加了gap锁（不论是共享gap锁还是独占gap锁）， 并不会限制其他事务		对这条记录加正经记录锁或者继续加gap锁
   >
   >    ​				可以对Supremum记录(页中最大的记录)加Gap Locks，指(最大的记录~+无穷)加锁
   >
   >    Next-Key Locks：为Record Locks+Gap Locks。( , ]能保护间隙和该记录。
   >
   >    Insert Intention Locks：插入时被阻塞了，等待时生成的锁结构
   >
   >    隐式锁：(1)使用锁定读时，被阻塞，给正访问的事务创建X锁，给自己创建锁结构，进入等待

7. 锁结构：

   > <img src="C:\Users\GgUpUp\AppData\Roaming\Typora\typora-user-images\image-20200529103743058.png" alt="image-20200529103743058" style="zoom:67%;" />
   >
   > 锁所在的事务信息、索引信息(对行锁有效)、
   >
   > 表锁／ ⾏锁信息：
   >
   > ​				表：记录是哪个表加锁；
   >
   > ​				行：Space ID： 记录所在表空间。 Page Number： 记录所在⻚号
   >
   > ​						n_bit：⼀个⻚⾯中包含很多记录， ⽤不同的⽐特位来区分到底是哪⼀条记录加了锁
   >
   > type_mode：
   >
   > ​				锁的模式（lock_mode）：X、S、IS、IX、AUTO-INC
   >
   > ​				锁的类型（lock_type）：表级锁、行级锁
   >
   > ​				⾏锁的具体类型（rec_lock_type）：next-key、gap、record-kocks
   >
   > 其他信息
   >
   > 比特位：⻚⾯中的每条记录有一个heap_no属性，锁结构最后的⼀堆⽐特位就对应着⼀个⻚⾯中的记		录，⼀个⽐特位映射⼀个heap_no。即⼀个⽐特位映射到⻚内的⼀条记录